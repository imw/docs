# VoÄ‰doni

Status of the document: *work in progress*

## A fully verifiable decentralized anonymous voting system

Cryptography and distributed p2p systems have brought a new, revolutionary digital technology which might change the way society organizes: blockchain. Among many other applications, it allows decision making through a secure, transparent, distributed and resilient voting system.

In this document, we propose the design, architecture of a decentralized anonymous voting platform using decentralized identities.

## Overview

We want to bring decentralized voting to mass adoption. This requires a solution that has a user experience at the level of current centralized solutions.

We achieve this by externalizing the heavy lifting to `relay` network, and unloading the end-user clients

+ Minimize transactions to the blockchain. Can potentially be used in the Ethereum Mainnet
+ `Voter` does not write, only reads from the blockchain
+ `Voter` can participate with an light-client (static web/app)
+ Secure vote anonymization using ZK-snarks
+ Data availability via distributed filesystems (IPFS)
+ Economically incentivized, `relay` network performs actions, not possible by light-clients
+ The whole `process` is verifiable by any external observer

![overall](https://github.com/vocdoni/docs/raw/master/img/overall_design.png)

### Identity
The system is agnostic to the identity scheme used.

We are developing our implementation using [Iden3](https://iden3.io), for having the best balance of decentralization vs scalability.

Other identity schemes could eventually be integrated.

## Definitions
_The following concepts are extensively referenced through the document_
### Actors
`Voter`
+ A `voter` is the end user that will vote
+ Its digital representation we call it `identity`
+ Inside the voting `process` is identified by a `public key`
+ Can manage all interactions through a light client (web/app)

`Organizer`
+ The user or entity that creates and manages a specific voting `process`
+ Needs to interact with the blockchain
+ Pays for the costs of a `process`
+ Has the highest interest for the `process` to succeed
+ Knows the census before hand (list of `Voters` `public keys`)

`Relay`
+ Is used as a proxy between the `voter` and the blockchain
+ Is a selfish actor. Good behaviour is ensured through economic incentives
+ It may have to be split into several `relay` types
+ Develops functions that would not be possible on a light-client
  - It relays `vote packages` to other `relays`
  - It aggregates `vote packages` and adds them into the blockchain
  - It validates `zk-snarks proofs`
  - It validates anti-spam proof-of-work nonce
  - It ensures data availability on IPFS
  - Is responsible for the data availability of the `vote packages` it has added (will lose stake if those are not available)
  - It exposes an IPFS proxy
  - It provides Merkle-proofs to `User` requests that they are in the `census Merkle tree`
  - It exposes an RPC end-point to the blockchain
  - It should run a full Ethereum node

### Elements

`Process`
+ We call `process` to a specific instance of a `voting process`

`Census Merkle Tree`
+ A Merkle-tree made of the `public keys` of all the `voters`
+ The Merkle-root is hosted in the blockchain as a proof of the census
+ The tree needs to be publicly available (IPFS) for everyone to verify it.
+ The sk-snarks circuit will use its root to validate if `voter` `public key` is part of it

`Voting smart-contract`
+ All metadata that defines a `process` is stored here
+ The `User` light clients retrieve the `process` data from here
+ All the aggregated `vote packages` hashes are added here
+ It holds the funds used to pay the `relays`
+ It holds the funds that the `relays` need to stake to ensure their good behaviour
+ When a `process` is successfully finished it transfers the funds to the `relays`

`ProcessId` (previously "election ID")
+ A unique identifier for each process
+ Generated by the `Voting smart-contract` when a new process is created

`Vote package`
+ Is the set of data sent by the `Voter` to the `relay` in order to vote 
  - Zk-snarks proof
  - Encrypted vote: encrypt(selected `vote options` + random nonce)
  - `Nullifier` : hash( `ProcessId` + `Voter` `private key` )
  - `ProcessId`
  - Anti spam proof of work

`Vote encryption key`
+ Is the public key used by the `Voters` to encrypt their vote
+ Its private key needs to be made publish at the end of the process, for everyone to validate the votes
+ Multiple `vote encryption keys` can be used to ensure that no one has access to the results before the `process` is finished

`Voting options`
+ A potential option for the user to choose when she votes
+ They are published when a `process` is created
+ They could be exclusive or not

`Zk-snarks proof`
+ A `Zk-snarks proof` that proves that the `user` can vote
+ It is generated in the `user` light-client
+ It is a CPU and memory intensive process

## Voting process chronology

### 0. `Identity` creation
  + Before the process in itself starts `voters` must have their digital `identity`  already created
  + The unique requirement for the those `identities` is that they need to be represented by a `public key`.
  + The system is agnostic to the identity system used but an integration will be required for each of them.

### 1. The `organizer` generates a census
  + This first design iteration, assumes that the `organizer` has a list of all the `voters` that can participate
  + It aggregates all the `public keys` of the `voters` and generates the `census Merkle tree` with them.

### 2. The `organizer` publishes a new voting process.
  + Via a user interface, it fills the required `process metadata` regarding a voting process.
    - Merkle Root  of the `census Merkle tree`
    - `Vote encryption key`
    - Available `voting options`
    - `Process` start time (block number)
    - `Process` end time (block number)
  + Sends a transaction to the `voting smart-contract`
    - It includes the `process metadata`, so its public for the other players
    - The funds sent in the transaction will be used to pay the `relays`
    - The amount sent is proportional to the needs of the `process` (number of participants, relay redundancy...)
  + In parallel it also publishes the `census Merkle tree` to IPFS, to make it available to everyone else.

### 3. `Voter` generates vote

#### Selects `voting options`
  + Gets the `process metadata` from the `voting smart-contract`
  + Gets the census Merkle-proof from a `relay`
  + Verifies her `public key` is in the published `census Merkle tree`
  + Selects the desired `voting options` from the `process metadata`

#### Generates vote
  + Encrypts the selected `voting options` and a random nonce with the `vote encryption keys`
    ```
     encrypted_vote = encrypt(selected_voting_options + random_nonce)
    ```
  + Generates the nullifier
    ```
    nullifier = hash( process_id + user_private_key)
    ```
#### `Zk-snarks proof` generation
The `zk-snarks proof` is used no anonymously prove two things:
  1. `Voter` is the owner of the `private key` corresponding to the `public key`
  2. `Voter`'s `public key` is included in the `census Merkle tree`

The `zk-snarks proof` is generated by running the `zk-snarks voting cicuit` with several inputs.

**private input**: `Private Key`, `census tree` Merkle-proof
**public input**: `census tree` Merkle-root, `Nullifier`, `ProcessId`,`encrypted vote`
**output**: `Zk-Snarks proof` that she can vote

+ It compiles the `vote package` with
  - `Zk-snarks proof`
  - `Encrypted vote`
  - `Nullifier`
+ Potentially it can encrypt the `vote package` with one or more `relay` publickeys in order to minimize IP mapping
+ Generates a Proof-of-Work nonce (to avoid relay node spamming)
+ It sends the `vote package` and the nonce the `relay` pool

### 4. `Relays` validate and add the `vote package` into the blockchain
  + The `relay` pool receives the `vote package` from the `user`
  + `Relay` nodes verifies the proof-of-work and the `Zk-snarks proof` if invalid the `vote-package` is discarded
  + Choose a set of pending `vote packages` and aggregate them into a single packet of data
  + Add the aggregated data to IPFS
  + Upload the IPFS hash to the blockchain

### 5. Finalizing the `process`
  + The owners of the `vote encryption keys` publish the corresponding `private keys`, so the votes and proofs can ve deencryoted
  + The `organizer` downloads and verifies the votes
  + The `organizer` signals bad `relays`
  + The `organizer` makes the `process` closing transaction
  + `Relay` are rewarded according to their contribution

![voting_process](https://github.com/vocdoni/docs/raw/master/img/voting_process.png)

### Unresolved questions
+ Most of the unresolved details are around creating a fully decentralized relay network
  + A centralized trusted `relay` it may still be a valid option in some cases
  + A centralized `relay` makes the system non BFT by not making data available
  + It can also very easily map an IP address to votes

+ How can we minimize IP address/vote mapping?
  + Multiple encryption with `relay` keys?
  + Use [I2P](https://en.wikipedia.org/wiki/I2P)
  + Use [Tor](https://en.wikipedia.org/wiki/Tor_(anonymity_network))
  
+ How does the `relay` pool look like? Is it a blockchain?
+ Do we need a `relay` market?
+ How does a `relay` compite with another `relay` pricing? Where are prices announced?
+ What is the prize of a `process` based on? Number of necessary transactions(not known before-hand)? 
+ How to check `relay` bad behaviour? Who checks it? (the `organization?`) Time limits for an un-returned hash?

+ How to choose which relay to encrypt the `vote package` with? How can it be randomized?
+ How a `User` chooses which relay connects to?
+ How does a `user` validate that her `vote-package` has been added into the blockchain?
  + Does it need to keep downloading every new hash of aggregated `vote packages`? 

### Known Weaknesses
- ZK-snarks trusted setup
- IP/vote mapping
- 